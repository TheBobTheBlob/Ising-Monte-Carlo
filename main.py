from typing import Callable
import random
from decimal import Decimal


def down_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of -1
    return Decimal(-1)


def up_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of 1
    return Decimal(1)


def alternating_state(i: Decimal, j: Decimal) -> Decimal:
    # Alternates between -1 and 1
    if (i + j) % 2 == 0:
        return Decimal(1)
    else:
        return Decimal(-1)


def random_state(i: Decimal, j: Decimal) -> Decimal:
    # Randomly returns either an up or down state
    return Decimal(random.choice([-1, 1]))

kB = Decimal(1.380649 * 10 ** -23)
T = 293
SIZE = 10  # Size of the grid
J = Decimal(1)
MICROSTATES = Decimal(2) ** (SIZE ** Decimal(2))

# Spins are represented by -1 and 1
# -1 = down
# 1 = up


def create_grid(size: int, value_func: Callable) -> list[list[Decimal]]:
    # Returns a grid of size x size filled with values generated by value_func
    # value_func should take two parameters (i, j) and return either -1 or 1
    grid = []

    for i in range(size):
        row = []
        for j in range(size):
            row.append(value_func(i, j))
        grid.append(row)

    return grid


def print_grid(grid: list[list[Decimal]]) -> None:
    # Print the grid in a readable format
    for row in grid:
        print(" ".join(f" {str(cell)}" if str(cell) == "1" else str(cell) for cell in row))


down_grid = create_grid(SIZE, down_state)
up_grid = create_grid(SIZE, up_state)
alternating_grid = create_grid(SIZE, alternating_state)
random_grid = create_grid(SIZE, random_state)



def calculate_energy(grid: list[list[Decimal]]) -> Decimal:
    # Calculate_energy should be calculating the entire energy from scratch

    energy = Decimal(0)
    for i in range(SIZE):
        for j in range(SIZE):
            neighbors = grid[(i + 1) % SIZE][j] + grid[i][(i + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1]
            energy += -neighbors * grid[i][j]
    return Decimal(energy / 4)

print("\nDown Grid:")
print_grid(down_grid)

print("\nUp Grid:")
print_grid(up_grid)

print("\nAlternating Grid:")
print_grid(alternating_grid)

print("\nRandom Grid:")
print_grid(random_grid)
print(f"\nEnergy of the random grid: {calculate_energy(random_grid)}")




# calculate_delta should be calculating the change in energy because of one flip
def calculate_delta(grid: list[list[Decimal]], i: int, j: int) -> Decimal:
    neighbors = grid[(i + 1) % SIZE][j] + grid[i][(i + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1]
    return Decimal(neighbors) * Decimal(grid[i][j]) 


def calculate_beta() -> Decimal:
    beta = Decimal(1) / (kB * T)
    return Decimal(beta)


def flip_spin(value: Decimal) -> Decimal:
    if value == Decimal(-1):
        return Decimal(1)
    else:
        return Decimal(-1)


for i, row in enumerate(random_grid):
    for j, cell in enumerate(row):
        delta = calculate_delta(random_grid, i, j)

        if delta <= Decimal(0):
            random_grid[i][j] = flip_spin(cell)
        else:
            probability = calculate_beta()
            random_value = random.random()

            if random_value < probability:
                random_grid[i][j] = flip_spin(cell)


print("\nModified Grid:")
print_grid(random_grid)
print(f"\nEnergy of the modified grid: {calculate_energy(random_grid)}")
