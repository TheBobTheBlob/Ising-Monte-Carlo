from typing import Callable
import random


def down_state(i: int, j: int) -> int:
    # Always returns a state of 0
    return 0


def up_state(i: int, j: int) -> int:
    # Always returns a state of 1
    return 1


def alternating_state(i: int, j: int) -> int:
    # Alternates between 0 and 1
    if (i + j) % 2 == 0:
        return 1
    else:
        return 0


def random_state(i: int, j: int) -> int:
    # Randomly returns either an up or down state
    return random.randint(0, 1)


SIZE = 10  # Size of the grid

# Spins are represented by 0 and 1
# 0 = down
# 1 = up


def create_grid(size: int, value_func: Callable) -> list[list[int]]:
    # Returns a grid of size x size filled with values generated by value_func
    # value_func should take two parameters (i, j) and return either 0 or 1
    grid = []

    for i in range(size):
        row = []
        for j in range(size):
            row.append(value_func(i, j))
        grid.append(row)

    return grid


def print_grid(grid: list[list[int]]) -> None:
    # Print the grid in a readable format
    for row in grid:
        print(" ".join(str(cell) for cell in row))


down_grid = create_grid(SIZE, down_state)
up_grid = create_grid(SIZE, up_state)
alternating_grid = create_grid(SIZE, alternating_state)
random_grid = create_grid(SIZE, random_state)

print("\nDown Grid:")
print_grid(down_grid)

print("\nUp Grid:")
print_grid(up_grid)

print("\nAlternating Grid:")
print_grid(alternating_grid)

print("\nRandom Grid:")
print_grid(random_grid)


def calculate_energy(grid: list[list[int]]) -> float:
    # Calculate_energy should be calculating the entire energy from scratch
    # I looked up a reference online and I think I followed it pretty closely

    energy = 0
    for i in range(SIZE):
        for j in range(SIZE):
            neighbors = grid[(i + 1) % SIZE][j] + grid[i][(i + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1]
            energy += -neighbors * grid[i][j]
    return energy / 4


# calculate_delta should be calculating the change in energy because of one flip
def calculate_delta(grid: list[list[int]], i: int, j: int) -> int:
    return 0


def calculate_beta() -> float:
    return 0


def flip_spin(value: int) -> int:
    if value == 0:
        return 1
    else:
        return 0


for i, row in enumerate(random_grid):
    for j, cell in enumerate(row):
        delta = calculate_delta(random_grid, i, j)

        if delta <= 0:
            random_grid[i][j] = flip_spin(cell)
        else:
            probability = calculate_beta()
            random_value = random.random()

            if random_value < probability:
                random_grid[i][j] = flip_spin(cell)


print("\nModified Grid:")
print_grid(random_grid)
print(f"\nEnergy of the modified grid: {calculate_energy(random_grid)}")
