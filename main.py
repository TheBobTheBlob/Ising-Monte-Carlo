from typing import Callable
import random
from decimal import Decimal
import math
import matplotlib.pyplot as plt

# Spins are represented by -1 and 1
# -1 = down
# 1 = up


# EDITABLE CONSTANTS

kB = Decimal(1)  # Boltzmann constant
T = 2  # Temperature
SIZE = 100  # Size of the grid
J = Decimal(-1)  # Interaction energy


# OTHER CONSTANTS

MICROSTATES = Decimal(2) ** (Decimal(SIZE) ** Decimal(2))


# STATE GENERATORS
# These functions generate the initial state of the grid based on the given parameters (i, j)


def down_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of -1
    return Decimal(-1)


def up_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of 1
    return Decimal(1)


def alternating_state(i: Decimal, j: Decimal) -> Decimal:
    # Alternates between -1 and 1
    if (i + j) % 2 == 0:
        return Decimal(1)
    else:
        return Decimal(-1)


def random_state(i: Decimal, j: Decimal) -> Decimal:
    # Randomly returns either an up or down state
    return Decimal(random.choice([-1, 1]))


# GRID FUNCTIONS


def create_grid(size: int, value_func: Callable) -> list[list[Decimal]]:
    # Returns a grid of size x size filled with values generated by value_func
    # value_func should take two parameters (i, j) and return either -1 or 1
    grid = []

    for i in range(size):
        row = []
        for j in range(size):
            row.append(value_func(i, j))
        grid.append(row)

    return grid


def print_grid(grid: list[list[Decimal]]) -> None:
    # Print the grid in a readable format
    for row in grid:
        print(" ".join(f" {str(cell)}" if str(cell) == "1" else str(cell) for cell in row))


def calculate_neighbours(grid: list[list[Decimal]], i: int, j: int) -> Decimal:
    # Calculate the sum of the neighbours times J
    # Neighbours are defined as the sum of the four adjacent cells (up, down, left, right)
    return J * (grid[(i + 1) % SIZE][j] + grid[i][(j + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1])


def calculate_energy(grid: list[list[Decimal]]) -> Decimal:
    # Calculate_energy should be calculating the energy of the grid from scratch
    energy = Decimal(0)
    for i in range(SIZE):
        for j in range(SIZE):
            energy += calculate_neighbours(grid, i, j) * grid[i][j]
    return energy / Decimal(2)


def calculate_delta(grid: list[list[Decimal]], i: int, j: int) -> Decimal:
    # calculate_delta should be calculating the change in energy because of one flip
    neighbours = calculate_neighbours(grid, i, j)

    energy_before = neighbours * grid[i][j]
    energy_after = neighbours * flip_spin(grid[i][j])

    return energy_after - energy_before


def calculate_beta() -> Decimal:
    beta = Decimal(1) / (kB * T)
    return Decimal(beta)


def flip_spin(value: Decimal) -> Decimal:
    if value == Decimal(-1):
        return Decimal(1)
    else:
        return Decimal(-1)


grids = {
    "down": create_grid(SIZE, down_state),
    "up": create_grid(SIZE, up_state),
    "alternating": create_grid(SIZE, alternating_state),
    "random": create_grid(SIZE, random_state),
}


# Change this to the grid you want to use
grid = grids["alternating"]

# Initial energy of the grid
print(f"\nInitial Energy of the chosen grid: {calculate_energy(grid) / Decimal(SIZE) ** Decimal(2)}")

energy_list = [calculate_energy(grid)]
for iteration in range(1000):
    energy = calculate_energy(grid)

    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            delta = calculate_delta(grid, i, j)

            if delta <= Decimal(0):
                grid[i][j] = flip_spin(cell)
                energy += delta
            else:
                probability = Decimal(math.e) ** (-calculate_beta() * delta)
                random_value = random.random()

                if random_value < probability:
                    grid[i][j] = flip_spin(cell)
                    energy += delta

    energy_list.append(energy)


print(f"\nEnergy of the final grid: {calculate_energy(grid) / Decimal(SIZE) ** Decimal(2)}")

x = list(range(len(energy_list)))

normalised_energy = []
for energy in energy_list:
    updated_energy = energy / Decimal(SIZE) ** Decimal(2)
    normalised_energy.append(float(updated_energy))


# Plotting the energy vs iterations
plt.plot(x, normalised_energy, label="Energy")
plt.xlabel("Iterations")
plt.ylabel("Energy")
plt.title("Energy vs Iterations")
plt.legend()
plt.grid()
plt.show()
