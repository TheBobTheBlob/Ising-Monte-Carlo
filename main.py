from typing import Callable
import random
from decimal import Decimal
import math
import matplotlib.pyplot as plt


# CONSTANTS

# kB = Decimal(1.380649) * Decimal(10) ** Decimal(-23)
kB = Decimal(1)
T = 1
SIZE = 100  # Size of the grid
J = Decimal(1)
MICROSTATES = Decimal(2) ** (Decimal(SIZE) ** Decimal(2))

# Spins are represented by -1 and 1
# -1 = down
# 1 = up


# STATE GENERATORS
# These functions generate the initial state of the grid based on the given parameters (i, j)


def down_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of -1
    return Decimal(-1)


def up_state(i: Decimal, j: Decimal) -> Decimal:
    # Always returns a state of 1
    return Decimal(1)


def alternating_state(i: Decimal, j: Decimal) -> Decimal:
    # Alternates between -1 and 1
    if (i + j) % 2 == 0:
        return Decimal(1)
    else:
        return Decimal(-1)


def random_state(i: Decimal, j: Decimal) -> Decimal:
    # Randomly returns either an up or down state
    return Decimal(random.choice([-1, 1]))


# GRID FUNCTIONS

def create_grid(size: int, value_func: Callable) -> list[list[Decimal]]:
    # Returns a grid of size x size filled with values generated by value_func
    # value_func should take two parameters (i, j) and return either -1 or 1
    grid = []

    for i in range(size):
        row = []
        for j in range(size):
            row.append(value_func(i, j))
        grid.append(row)

    return grid


def print_grid(grid: list[list[Decimal]]) -> None:
    # Print the grid in a readable format
    for row in grid:
        print(" ".join(f" {str(cell)}" if str(cell) == "1" else str(cell) for cell in row))


def calculate_energy(grid: list[list[Decimal]]) -> Decimal:
    # Calculate_energy should be calculating the energy of the grid from scratch
    energy = Decimal(0)
    for i in range(SIZE):
        for j in range(SIZE):
            neighbors = grid[(i + 1) % SIZE][j] + grid[i][(j + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1]
            energy += -neighbors * grid[i][j]
    return energy / Decimal(2) / Decimal(SIZE) ** Decimal(2)


def calculate_delta(grid: list[list[Decimal]], i: int, j: int) -> Decimal:
    # calculate_delta should be calculating the change in energy because of one flip
    neighbours = grid[(i + 1) % SIZE][j] + grid[i][(j + 1) % SIZE] + grid[i - 1][j] + grid[i][j - 1]

    energy_before = (neighbours * grid[i][j]) / Decimal(2) / Decimal(SIZE) ** Decimal(2)
    energy_after = (neighbours * flip_spin(grid[i][j])) / Decimal(2)  / Decimal(SIZE) ** Decimal(2)

    return energy_after - energy_before


def calculate_beta() -> Decimal:
    beta = Decimal(1) / (kB * T)
    return Decimal(beta)


def flip_spin(value: Decimal) -> Decimal:
    if value == Decimal(-1):
        return Decimal(1)
    else:
        return Decimal(-1)


grids = {
    "down": create_grid(SIZE, down_state),
    "up": create_grid(SIZE, up_state),
    "alternating": create_grid(SIZE, alternating_state),
    "random": create_grid(SIZE, random_state),
}


# for name, grid in grids.items():
#     print(f"\n{name.capitalize()} Grid:")
#     print_grid(grid)


# Change this to the grid you want to use
grid = grids["alternating"]

# Initial energy of the grid
print(f"\nInitial Energy of the chosen grid: {calculate_energy(grid)}")

energy_list = []
for _ in range(100):
    energy = calculate_energy(grid)
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            delta = calculate_delta(grid, i, j)

            if delta <= Decimal(0):
                grid[i][j] = flip_spin(cell)
                energy += delta
            else:
                probability = Decimal(math.e) ** (-calculate_beta() * delta)
                random_value = random.random()

                if random_value < probability:
                    grid[i][j] = flip_spin(cell)
                    energy += delta

    energy_list.append(float(energy))


# print_grid(grid)
print(f"\nEnergy of the final grid: {calculate_energy(grid)}")

x = list(range(len(energy_list)))

# Plotting the energy vs iterations
plt.plot(x, energy_list, label="Energy")
plt.xlabel("Iterations")
plt.ylabel("Energy")
plt.title("Energy vs Iterations")
plt.legend()
plt.grid()
plt.show()
